#pragma once

/*
	抽象工厂模式
	工厂模式把原先
		类名*指针名=new 类构造函数();
	这种插件对象的编译时绑定，通过虚函数的方式改写为：
		工厂指针（由外部传入，指向具体工厂对象）
		基类*指针名=工厂指针->创建对象();//虚函数，根据具体的工厂多态创建对应的对象
	因此，创建对象的类型到底是什么，这由外部传入的工厂指针决定。
	相当于将编译时绑定转移到了外部，内部实现了运行时绑定

	工厂创建的的对象之间独立。但如果存在某种情况，对象彼此之间有配套关系，
	例如：
		基类1有ABC三种子类，由工厂1来创建
		基类2由abc三种子类，由工厂2来创建
		但是A只能配合a使用，BC同理
		A与b或者c是不能配合的，因此
		两个工厂虽然有6种配对，但只有3种可行
		因此应该使用一个工厂来创建一整套即可
	取消工厂1和工厂2，创建工厂基类，包含两个（一组有几个对象，就对应几个）虚函数，任务是创建对象
	然后派生3个工厂类，每个工厂类实现创建一组对象，共3种可能
	然后将指向具体工厂的基类工厂指针传给创建对象的地方。
	直接使用该指针调用虚函数，利用多态具体创建一组对象。


	抽象工厂模式并不是将工厂多一层抽象，而是将多个不同系得工厂整合到一起，使得创建的一组对象是配对的。
	抽象工厂可以应对组合上的变化。如果需要一组新的对象，就从基类工厂派生一个工厂来创建这组对象，
	但要求一组的数量是一致的，因此抽象工厂无法应对数量上的变化

*/