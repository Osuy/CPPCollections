#pragma once

/*
	装饰器模式
	利用组合代替继承，实现多个功能的组合

	基类有一个虚函数func，需要实现某一功能
	这个功能有n个大方向，m个小方向。大方向互斥，小方向兼容
	例如输入输出流，
		大方向有：网络流、内存流、文件流
		小方向有：加密流、缓冲流
	组合有：加密网络流、加密缓冲网络流...
	于是有n*m!种组合。倘若用继承实现这些功能，就需要派生n*m!个类。这显然违背了复用性

	装饰器模式的思路是，用类组合的方式将不同的功能组合起来。
	大方向和小方向的类仍然直接派生自基类。不同的是小方向内部包含一个基类指针b_obj，
	小方向类重写虚函数func，实现自己小方向的功能，然后b_obj->func();//也就是嵌套多态func
	小方向类的构造函数接收一个派生自基类的对象。
	这样，
		小方向对象指针->func();//就能同时运行自己的小方向功能，又能运行内部对象的func功能。而其内部对象也是若干个功能的组合
	另外，所有小方向类内部都需要一个基类指针，所以可以再抽象一层
	定义一个派生自基类的虚基类Decorator，内部包含一个基类指针，权限为protected
	所有小方向类派生自Decorator，然后重写func，func内部调用基类指针->func();


	装饰器特征：
		派生自基类，又包含基类指针
		重写的虚函数内部调用了指针->同名虚函数

	装饰器适合用于某一个虚函数存在多个方向的分化却又需要这些方向的组合
	装饰器模式是基于同名虚函数的多态，不同名的应该使用桥接模式

*/