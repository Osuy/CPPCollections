#pragma once

/*
	explicit
	修饰单参构造函数，使其必须为显式调用。
	如，TestClass有构造函数：
		TestClass(int a);
	那么可以隐式地使用构造函数，如下
		TestClass a = 1;//调用单参构造函数TestClass(1)构造临时对象，再赋值给a
	为了避免直接使用=号赋值这种奇怪初始化方式。需要指明单参构造函数为显式
	即使用explicit来修饰单参构造函数
		explicit TestClass(int a);


	volatile
	高级语言对于对象的创建，尤其是new
		A* a=new A();
		具体的做法是：
		1.申请一块sizeof(A)大小的内存
		2.在内存上调用A的构造函数
		3.将地址返回给a指针
	但是解释成汇编语言之后，（非常）可能变化其顺序：
		1.申请一块sizeof(A)大小的内存
		2.将地址返回给a指针
		3.在内存上调用A的构造函数
	这造成一个多线程不安全问题。
		假如A为懒汉单例模式的对象。第一个线程请求时，开始创建对象，此时第二个线程进入，发现对象指针不为空，于是拿去使用
		但是还没调用构造函数，对象没有构造完成，这就造成了野指针的风险
		这个问题称为：内存reorder
	C++11中添加了volatile关键词，被它修饰的指针，在创建对象时，总会以申请内存、调用构造、返回地址的顺序创建，从而保证了多线程环境的安全。

*/

