#pragma once

/*
	构造函数初始化列表的使用形式如下：
		TestClass(参数列表): 成员1(参数1), 成员2(参数2) ...{...}
	初始化列表可以调用基类的构造函数，如:
		Derive(...): Base(a), ... {...} //在初始化列表调用基类构造

	初始化顺序以类内的声明顺序为准。
	a在类内的声明先于b，那么即便a的初始化不在初始化列表第一个，也会首先初始化。
*/

/*
	对于不包含指针成员的类，称其具有“平凡的析构”，相反，对于包含指针成员的类，称其具有“不平凡的析构”
	
	平凡的析构可以不做任何事；
	不平凡的析构必须要释放对象的指针成员
*/

/*
	构造函数二义性：
	假如TestClass有两个构造函数：
		TestClass(double a);
		TestClass(long a);
	那么，当使用int类型调用构造函数时，编译器将无法确定到底是把int转化为long还是double
	因此，对于一些可以互相转化的基本类型，更稳妥的做法是一一声明对应的构造函数：
		TestClass(int a);
		TestClass(double a);
		TestClass(long a);
	这样就不会因为某一类型的缺失而去调用其他需要隐式转化的版本
	建议将所有可能的构造函数都声明，以避免隐式转换
*/

/*
	explicit
	修饰单参构造函数，使其必须为显式调用。构造函数默认式implicit(隐式)的
	如，TestClass有构造函数：
		TestClass(int a);
	那么可以隐式地使用构造函数，如下
		TestClass a = 1;//调用单参构造函数TestClass(1)构造临时对象，再赋值给a
	为了避免直接使用=号赋值这种奇怪初始化方式。需要指明单参构造函数为显式
	即使用explicit来修饰单参构造函数
		explicit TestClass(int a);

*/

/*
	转换函数
	将自定义类型转化为基本类型的成员函数
	类似于implicit的单参构造。
		TestClass a = 1
	实际上，如果具有对应的转换函数，那么下面的语句也是可行的。
		int b = a;//左边int，右边TestClas

	转换函数的声明如下：
		typeName operator typeName()const;//
	以int为例：
		int operator int()const;
	如果书写了合适的转换函数，那么自定义类型是可以直接赋值给基本类型的
*/

/*
	虚函数
	对包含虚函数的类，编译器会为其添加一个隐藏的指针，指向虚函数地址数组（也称虚函数表，是一个指针数组）
	对于每个类，编译器都会为其创建一个虚函数地址表
	基类对象包含一个指针，指向基类虚函数表；派生类对象包含一个指针，指向派生类虚函数表
	如果派生类没有重写基类的虚函数，那么虚函数表保存基类函数的地址。
	但如果派生类重写了基类的虚函数，那么虚函数表会保存新函数的地址。

	如果使用指向对象的引用或指针调用虚方法，持续将根据对象的类型调用虚函数，而非根据指针或引用的类型。
	这样便实现了多态。

	构造函数不能是虚函数。因为构造函数总会与要创建的对象的类型相同，不需要多态
	析构函数应当是虚函数。因为析构函数与指向对象的引用或指针的类型相同，可能存在调用基类析构的情况。

	友元函数不能是虚函数，虚函数必须是成员函数。
*/