#pragma once

/*
	滑动窗口
	用于求解带有“最长”、“最短”等数组或字符串匹配的问题
	例如：字符串的最长不重复子串、包含全部字符的最短子串
	这一类问题一般都有一个特点，就是求子串的长度
	并且子串有一定的要求，如重复、不重复、元素之和最大...



	这就需要开辟一个额外的数组来记录它们的元素出现的频度。
	对于数值，直接创建int数组
	对于字符，也是创建int数组，而每个元素对应的下标是c-'A'（如果是全小写字母，则c-'a'）
		当然也有可能是大小写全都有，在ascii码中，大小写字符不是连续的，因此还是用unordered map来储存频度

	right++的过程中，如果遇到的字符频度为0，说明第一次遇到，
	left++的过程中，如果遇到的字符频度为1，说明这个字符已经不重复，而且最后一个字符会在此次left++时离开

		还用一种题型是，求字符串s中出现字符串t中所有字符的字串，这时
		频度先用t初始化，然后
		right++时，频度--，如果减至0，说明该字符已全部包含，
		left++时，频度++，如果加至1（加之前是0），说明该字符不能全部包含

	滑动窗口需要两个变量，表示窗口的左右边界。
	为了更方便得到窗口的大小，采用左闭右开区间。这样，右边界 - 左边界 = 窗口长度
	起始左右边界都指向0，当右边界到达串的尾部停止。循环每次循环大体做两件事：
		1.右边界总是右移
		2.左边界根据情况是否需要右移
	如果根据题目，需要窗口的大小只变大，不变小。那么，需要额外的变量存储最大值，这个最大值也是只变大不变小。
	如果没找到更大的值，循环内就是左右边界都右移，如果找到了，右边界移，左边界不移


	对于求最长、最大：
		一般初始状态是满足的
		如果右边界右移使区间满足条件，则左边界不移
		否则，左边界也跟着右边界一起移动（整体右移）
		直到右边界到达尾部，退出循环
		虽然区间整体右移，并不一定会满足条件，但是求的是最大，因此，区间变小是没有意义的。
	伪代码：
		while(右边界未到达尾部）
		{
			//其他处理
			右边界右移

			if(不满足条件)
			{
				左边界右移;
			}
		}


	对于求最短、最小：
		一般初始状态是不满足的
		右边界负责使区间满足条件
		左边界负责剔除可有可无的元素，通常伴随着记录的处理。
		当右边界使区间满足条件，左边界就右移多次（用循环），使区间变成不满足
		于是接下来外循环，右边继续移动
		当再次满足条件，且区间更小，则更新最小区间，
		最终右边界达到尾部，于是左边界一直右移，也到达尾部，退出循环
	
	伪代码：
		循环(右边界未到达尾部)
		{
			//其他处理
			右边界右移

			while(满足条件)
			{
				左边界右移;
			}
		}



	求最小和求最大，外循环总是右边界右移，
	求最大，左边界可能右移一次（if(不满足)，使区间整体右移）
	求最小，左边界可能右移很多次（while(满足)，使区间缩小，直到再次变成不满足）

		






*/