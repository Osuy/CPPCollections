#pragma once

/*
	前言
	推排序利用完全二叉树的向下调整性实现了元素的有序出列。
	大顶堆的特征是，父节点比子节点大。左右子树又是一个大顶堆
	因此数组最大元素为根，即下标为0；
	
	堆调整算法至关重要，需要的参数有：数组、父节点、数组尾节点
	将其值赋给最后一个元素，最后一个元素值赋给tmp，调整大顶堆。
		找到左右子交点中较大的一个，如果大于tmp，赋给父节点，向下继续寻找
		直到找到一个节点，它的两个子节点都不比tmp大，然后将tmp赋给目标。（目标的值已经在上一次循环赋给了父节点）
	

	首先根据数组创建大顶堆：
		直接用数组创建堆，然后找到第一个非叶子节点（(n-1-1)/2），然后向前遍历，对每个节点都进行调整。
*/


//在区间内，对arr[begin]进行向下调整
void heapfy(int* arr, int begin, int end)
{
	int tmp = arr[begin];//保存区间的第一个元素的值
	int i = begin, j = i * 2 + 1;//i和j分别指向第一个元素和其左孩子
	while (j <= end)//j出界，说明没有孩子了，当前i指向的就是叶子节点，可以作为tmp的位置
	{
		if (j + 1 <= end && arr[j] < arr[j + 1])//如果右孩子存在，且更大，则j指向右孩子（事实上j可以指向右孩子，但退出循环后还需要加上可能仅有左孩子的情况的补充）
			j = j + 1;
		if (arr[j] > tmp)//如果孩子比tmp大，将孩子赋给父，更新i和j以便下一循环
		{
			arr[i] = arr[j];
			i = j;
			j = i * 2 + 1;
		}
		else//如果孩子比tmp小，说明当前i的位置可以放置tmp，直接退出循环
			break;
	}
	arr[i] = tmp;//将tmp赋给找到的i
}

void HeapSort(int* arr, int len)
{
	//make max heap
	//从最后一个非叶子节点（有孩子）开始，向前循环，对其做大顶堆调整
	//最终使整个数组建成一个大顶堆
	for (int i = len / 2 - 1; i >= 0; --i)
	{
		heapfy(arr, i, len - 1);
	}

	//交换堆顶元素和末尾元素，调整堆。循环后，得到降序数组
	for (int i = len - 1; i >= 0; --i)
	{
		arr[i] ^= arr[0];
		arr[0] ^= arr[i];
		arr[i] ^= arr[0];
		heapfy(arr, 0, i - 1);//下界是i-1的原因：arr[0]和arr[i]交换后，i存放之前的堆顶元素。下界为i-1，调整就不会对i赋值
	}
}


/*
	topk问题
	在n个元素内取前k个最大元素

	三种方法：
		O(nlogn)：使用快排后取k个元素
		O(kn)   ：使用不完全的冒泡排序（冒泡排序内循环取剩余最大值，外循环n遍，修改为k遍即可）
		O(nlogk)：使用小顶堆。对数组前k个元素建立小顶堆，然后遍历剩余数组。若比堆顶元素大，则替换然后调整堆

	因为小顶堆的所有子节点都比根节点大，用于存储最大元素。
	遍历数组，每遇到一个比堆顶还大的数，就存入堆中（赋给堆顶，然后调整）
	完成遍历后，最大的k个元素都被存入堆中。
	最后，对小顶堆进行堆排序，得到降序数组，即前k个最大的数。
*/