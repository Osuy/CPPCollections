#pragma once

/*
	工厂模式
		工厂创建代替绑定创建

	传统创建一个对象，都是在代码里写死。例如
		class A{...};
		A* a_obj=new A(...);
	假若现在需求变化了，要创建的是class B{...}，就要整段代码修改：
		B* b_obj=new B(...);
	通常为了实现多态，A类和B类可能派生自同一个基类class Father{...};
	于是可以写成：
		Father* obj=new A(...);
	虽然说用father指针确实可以实现多态，但是 new后面还是写死的。
	假如需求改变，就要把new A(...) 改写成 new B(...)
	这不符合依赖倒置原则，抽象的father指针与具体的类绑定，造成代码编译时依赖，需要随时修改
	
	工厂模式的目的就是将手动new对象的工作交给工厂，由工厂来赋值创建，最重要的是用虚函数取消编译时依赖
	定义一个创建对象的抽象基类，再派生不同的工厂用于创建各自的对象。
	将指向具体工厂的抽象工厂指针传给需要创建对象的地方。
	从而将创建对象的编译时依赖转移到其他地方，

	工厂模式可以应对需要创建的对象类型变化的需求
*/