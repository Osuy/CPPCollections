#pragma once

/*
	0-1背包问题
	有n个物品，第i个物品的价值为vi，重为wi，其中vi和wi均为非负数
	背包容量为W
	选择物品放入背包，使背包内的物品的总价值最大

	设xi表示物品i是否放入背包，取0或1
		maxW=Σ(vi * xi)
	约束条件为：
		Σ(wi * xi) <= W


	1.刻画最优解结构
		对于某个解，物品n放在背包里，则x1,x2,..,xn-1是一个子问题
		这个子问题是：对于W-wn，从1,2,...,n-1物品重，选择放入背包的物品是总价值最大
		对于考虑i个物品，在Wi容量的，最大价值，取以下两个值的较大值：
			1.放得进去，放入i，vi + i-1个物品在Wi - wi容量的最大价值
			2.放不进去或放得进去但不放入i，即i-1个物品在Wi容量的最大价值

	2.递归定义最优解的值
		设c[i,w]表示背包容量为w时，i个物品导致最优解的总价值
		即有：
			c[i,w]=1. 0，当i=0或w=0
				   2. c[i-1,w]，当wi>W
				   3. max(c[i-1,w-wi]+vi,c[i-1,w])，当i>0且wi<=w

		对于第3种情况：比较i放进去还是不放进去的背包总价值

	3.计算最优解的值
*/

/*
	n：物品个数
	W：背包最大容量
	Weights：物品重量数组
	Value：物品价值数组
*/
int** KnapsackDP(int n, int W, int* Weights, float* Values)
{
	int i, w;
	int** c = (int**)malloc(sizeof(int*) * (n + 1));
	//c是一张表，表示子问题的解的表
	//第一个维度：考虑前i个物品
	//第二个维度：背包的可容纳重量w
	//值：表示前i个物品在容量为w时的最大价值

	for (i = 0; i <= n; ++i)
		c[i] = (int*)malloc(sizeof(int) * (W + 1));

	for (w = 0; w <= W; ++w)
		c[0][w] = 0;

	for (i = 1; i <= n; ++i)//试图放进第i个物品，已经考虑了前i-1个物品
	{
		c[i][0] = 0;        //背包可容纳重量为0，当然放不进去东西，置0
		for (w = 1; w <= W; ++w)//逐渐增加背包的可容纳重量，直到W
		{
			if (Weights[i - 1] <= w)//如果物品i的重量可以放进背包
			{
				//如果物品i的价值加上前i-1个物品在重量为(w - Weights[i - 1])的最大价值
				//大于前i-1个物品在w的最大价值
				//则c[i][w]=前者
				//否则c[i][w]=后者
				if (Values[i - 1] + c[i - 1][w - Weights[i - 1]] > c[i - 1][w])
					c[i][w] = Values[i - 1] + c[i - 1][w - Weights[i - 1]];
				else
					c[i][w] = c[i - 1][w];
			}
			else
				//如果放不进去，则直接等于前i-1个物品在重量为w的解
				c[i][w] = c[i - 1][w];
		}
	}
	return c;
}

//根据得到的二维数组c求序列x，即哪些物品放进背包
//不难，省略