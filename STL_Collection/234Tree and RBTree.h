#pragma once


/*
	直接学习和掌握红黑树是十分困难的。
	红黑树的初衷是设计一种二叉树，使其能满足4阶B树的使用需求。
	因此在学习红黑树之前，首先要简单地了解234树。
*/

/*
	234树的特点：
		234树的key是有序的
		每个树节点包含1~3个key，分别称为2节点（1key2孩子），3节点（2key3孩子），4节点（3key4孩子）
		特别注意：除叶子节点外，2节点必须有2个孩子，3节点必须有3个孩子，4节点必须有4个孩子
				 即234树一定是完全树，否则需要做节点合并和分裂。

		对于一个树节点(a,b,c)，
			--1--小于a的key在a的左子树上
			--2--大于等于a且小于b的key在ab之间的子树上
			--3--大于等于b且小于c的key在bc之间的子树上
			--4--大于等于c的key在c的右子树上

	234树的插入：
		若插入的key已存在，则插入失败
		若插入的key不存在，则最终一定会插在树的叶子节点（最底层）
			--1--若插入目标不是4节点，则直接插入
			--2--若插入目标是4节点，则需要分裂：
			     --1--4节点的分裂：左右两个key降层，成为中间key的左右子树，于是得到3个2节点
				 --2--插入的key插入左孩子或右孩子（不可能是中间key）
				 --3--由于叶子结点分裂，多了一层，因此需要把中间key向上合并
				 --4--将向上合并的过程看成中间节点的key向上插入，然后重复之前的步骤
	234树的插入如果导致根节点从4节点分裂，就会使234树的层数增加

	234树的删除：
		若删除的key不存在，则删除失败
		若删除的key存在：
			--1--若删除的key不在叶子节点上，则删除之，用后继key覆盖
				----然后在后继key所在的节点上删除后继key
				----删除后继key是一个重复的过程，直到后继key在叶子节点上
			--2--若删除的key在叶子节点上，则
				--1--所在节点不是2节点，直接删除
				--2--所在节点是2节点，删除该节点，然后
					--1--若兄弟节点不是2节点，兄弟节点取出一个key给父节点，父节点再取一个key下移到被删除节点
					--2--若兄弟节点是2节点，父节点不是2节点，则父节点取出一个key给兄弟，使父称为2节点，兄弟称为3节点
					--3--若兄弟节点是2节点，父节点也是2节点，，则兄弟向上与父节点合并
						----然后考虑合并节点的兄弟节点和父节点，重复前3步
	234树的删除导致根节点参与合并，将会使树的层数降低



*/

/*
	红黑树和234树是完全等价的。
	红黑树的设计初衷就是以二叉树的形式实现234树。

	红黑树没有AVL树的绝对平衡，因此旋转操作更少，效率更好。
	
	红黑树的特征：
		1.节点只有红色和黑色两种颜色
		2.根节点一定是黑色
		3.空节点指向名为NIL的黑色节点
		4.红色节点的两个子节点都是黑色（或NIL）
		5.从任一节点其子树的叶子或NIL的路径上所含的黑色节点数量相同

	4和5组合起来就是，红黑树的最浅叶子和最深叶子的深度相差一倍。
	
	难以理解的是第3点，为何需要用NIL表示空节点。
	若计算任一节点到底下两层叶子的路径上的黑色节点，那么NIL有没有都不会有影响
	但如果在树的底下两层的上方有空节点，那么需要用NIL表示它为一个叶子。从而正确计算黑色节点的个数


	红黑树和234树的变形
		如果将红黑树的黑节点与它的红孩子合并，那么红黑树就是234树
			----若黑节点没有红孩子，则看成2节点
			----若黑节点有1个红孩子，则合并，看成3节点
			----若黑节点有2个红孩子，则合并，看成4节点

		根据特征5，合并后，没有红节点的路径和有红节点的路径一样长。
		于是乎，所有叶子节点都在树的最底层，这便是一棵234树

		红黑树的插入：
			如果插入的key已存在，则修改value
			如果插入的key不存在，则根据二分查找，找到合适的叶子节点作为父节点进行插入
				--1--如果父节点是黑节点，直接插入
				--2--如果父节点是红节点，将父节点、叔节点和祖父节点合并，是一个3或4节点。
					 根据叔节点的颜色，有红和空两种情况
					----如果叔节点为空，和AVL树的插入一样，
						--1--如果为外侧插入，进行一次左/右旋，把父节点染黑，祖父染红
						--2--如果是内侧插入，进行一次双选，把自己染黑，祖父染红
					----如果叔节点为红色，即祖父节点是一个4节点
						----对一个4节点插入，需要向上合并（234树需要选一个key上移，二叉树显然直接将祖父上移）
						----将父节点和叔节点染黑，祖父染红。直接将key插入在父节点（因为染黑了，直接插入）
						----将祖父作为当前节点，插入到曾祖父。重复插入过程即可。
						----直到重复到根节点。此时，将旋转后的真正的根节点染黑即可

		纵观来看，只有父节点为红，叔节点为NIL时，才会需要旋转，其他情况只需要染色即可。
		可以看出，红黑树相比于AVL树，很少会旋转，更多的是染色
				

		红黑树的删除：
			若删除的key不存在，删除失败
			若删除的key存在：
				--1--若删除的key不是叶子节点，用孩子的值覆盖（优先右孩子），然后删除孩子
					----若孩子不是叶子，则重复直到孩子是叶子节点
					----若孩子是叶子节点，执行步骤2（下一行）
				--2--若删除的key是叶子节点
					--1--若目标节点为红色，直接删除
					--2--若目标节点为黑色
						--1--如果兄弟不是2节点（为黑且有孩子），
							--1--兄弟有右孩子，删除目标节点，做一次双旋转，兄弟的右孩子变为父节点并染黑，父节点移到自己的位置（保持黑色）
							--2--兄弟没有右孩子，删除目标节点，做一次单旋转，兄弟变为父节点，其孩子变为兄弟并染黑，父节点移到自己的位置
						--2--如果兄弟是2节点（为黑没有孩子），且父节点为红，一次单旋转，父亲和兄弟交换位置
						--3--如果兄弟是2节点，父节点为黑，则兄弟变红，以父节点的兄弟为新的兄弟考虑情况，重复此1，2，3步骤



*/