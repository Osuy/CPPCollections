#pragma once



/*
	关于构造函数和析构函数
	不能认为：构造函数获得了内存、析构函数释放了内存
	构造函数的本质作用是，对象获得内存后应该干什么（为成员赋值，为成员指针调用其构造）
	析构函数的本质作用是，对象在被释放前应该做什么（为成员指针调用其析构）
	从上面看来，构造和析构实际上更像事件而非函数。（事件返回值是void，而构造析构无返回，也是相似的理由）
	因为，一个对象的创建，实际上是new在包揽全活
	如下：
		【TestClass p* = new TestClass();】做了3件事：
		void* mem = operator new(sizeof(TestClass));    //用operator new 分配内存。如果没有重载，会调用::operator new
		p = static_cast<TestClass*>(mem);               //将(void*)类型静态转化为(TestClass*)
		p->TestClass::TestClass();                      //p指针调用TestClass的构造函数，相当于触发了构造事件。

		同理，【delete p;】这行语句做了2件事：
		p->~TestClass();                                //p调用TestClass的析构函数，触发析构事件
		operator delete(p);                             /用operator来释放p的内存

		注意事项：
		p->TestClass::TestClass();//这行语句如果由用户书写是不能编译通过的。
		因此如果由用户自行设计内存分配而又需要调用构造函数，应该使用下面的定位new写法：
		new(p) TestClass();//new调用构造函数，将对象指针放在p的地址上。

	如果TestClass内部包含int变量，那么构造函数只不过是给int赋值，而析构函数则无重要作用(trivial)
	但是如果TestClass内部包含TestClass2类型的指针，那么构造和析构可以有用武之地：
		构造函数内部可以new TestClass2()来给指针赋值，调用TestClass2的构造函数
		析构函数内部可以delete 指针来释放指针
	现在不难理解各个教材必会提及：构造先外后内，析构先内后外。
	因为在构造函数里给内部指针赋值，调用内部指针类型的构造函数
	在析构函数内释放内部指针，调用内部指针类型的析构函数

	总结：构造和析构的作用不是获取和释放内存，而是在获取内存后/释放内存前做一些事。
	而它们应该去做的最重要的事，就是调用成员指针的构造/析构。（如果类内没有指针，则析构无重要作用）

*/

/*
	内存泄漏之释放数组
	释放数组是最常发生内存泄漏的情况。具体代码范例见以下

	TestClass* array = TestClass[3]; 
	delete[] array;//无泄漏
	delete array;//可能泄漏

	以上，规范的释放数组是使用delete[]，但是为什么用delete只是可能泄漏而不是必定泄漏呢？
	这要先理解数组的本质：向系统申请一个数组时，得到是一个cookie和一连串用于存放元素的空间。
	cookie包含了数组的长度。
	无论用delete还是delete[]，都会完整地释放整个数组的空间。不同的是delete[]会多次调用析构，而delete只调用一次
	释放整个数组的空间。那不就不会泄漏吗？不会吗？好好想想。如果TestClass内部没有指针，确实不会泄漏。
	因为TestClass内部没有指针，所以它的析构是trivial的。无论调用一次还是多次都不会有差别
	但是如果TestClass内部包含指针，那么多次调用析构函数才能完全释放那些内部指针所指的内存。
	而如果用delete，仅调用一次，那么剩余的内部指针被释放，所指的内存却没有释放，这便是内存泄漏。

	以上，是否和你以往认为的内存泄漏不一样，泄漏不是发生载释放数组，而是发生在没有多次调用析构。

*/


/*
	存储持续性、作用域和链接性

	存储持续性
	自动：函数、代码块中的变量以及临时变量。存放在栈中，自动分配和释放
	静态：函数外，或者用static修饰的变量。存放在静态区中，程序运行期间始终存在。结束后释放。
	动态：用new操作符分配内存的变量。存放在堆区，一直存在，直到用delete释放或程序结束。

	作用域
	函数和代码块内的变量，无论是自动、静态还是动态，都只在该代码块内有效。
		自动变量会在代码块结束时释放
		静态变量在任何执行到代码块的时候都有效，并且其值是持续的
		动态变量在代码块结束后没有delete就会造成内存泄漏。下一次执行到代码块会分配新的动态变量而不会找回之前的（之前的动态成为野变量）

	对于静态变量而言，如下两种在函数外的声明：
	int a;
	static int b;
	其中，a为外部链接性，其他文件只要#include此文件且extern int a;即可使用a
	但是，b为内部链接性，其他文件无法使用
	综合，static修饰的变量是内部静态的，只能此文件使用；如果还是局部的，就只能在代码块内使用
	
	所有函数都是静态的，默认为外部链接，可以文件间共享。但可以用static修饰函数，使其只能内部使用。
	另外，如果文件内部的静态函数和extern外部的某函数同名，那么外部的函数总会被覆盖而无法调用到。

	在C++中，可以用类名::函数名来调用外部文件的静态函数，而不会因为内部链接性而失败。

*/