#pragma once
#include <mutex>
#include <list>

/*
	3.1共享数据的问题

	假设有两个线程读写同一个链表，其中一个在遍历，而另一个在删除某个节点
	删除一个迭代器，意味着要重新调整前驱、后继节点的指针，因此会影响三个节点
	如果A线程访问的迭代器不是这三个节点的迭代器，那么访问正常，如果是，或者即将在删除之前访问
	（删除一个节点所执行的指令数量显然大于读取，因此可能删除完成之前就遍历到了）
	那么就会得到错误的遍历结果
	（一般而言遍历总是正序的，因此，如果先调整前驱节点的后继指针，再调整后继节点的前驱指针
	那么遍历结果也是正确的，但是如果逆序访问，则是错误的
	所以建议调整指针的循环是先前驱后后继）

	上例也揭示了一个线程同时访问资源的错误的必要条件
	写操作是一个非原子操作，可能有多个步骤。而在所有步骤完成之前，资源出于非法状态
	此时却被其他线程访问，得到了一个非法的结果
	而如果写操作是原子操作，单指令立即完成，就不会有发生错误的机会

	资源竞争难以复现而且难以察觉，因为计算机完全认为那是正确的，但结果不符合人类的预期
	并且可能在调试时又恢复正常，因为调试环境和实际运行环境有些许差异，使资源竞争的错误没有发生

	3.2互斥保护
	最通用的共享保护
	只有请求互斥成功后才能继续执行，否则阻塞。一个线程如果请求成功，那么其他线程只能等待
	mutex 的 lock 必须和 unlock 配合使用。但是更建议使用标准库提供的raii类lock_guard去管理

	同样，对于链表，为了禁止两个线程同时竞争，可以对读写操作互斥
*/

std::mutex mtx;
std::list<int> l;
void read_list()
{
	std::lock_guard<std::mutex> guard{ mtx };
	std::find(l.begin(), l.end(), 1);
}

void write_list()
{
	std::lock_guard<std::mutex> guard{ mtx };
	l.push_back(1);
}

/*
	互斥全局变量mtx在以上两个函数里对链表l进行互斥保护
	然而对于其他链表，也需要声明同样的互斥变量
	因此更好的做法是将互斥变量和要保护的资源封装为一个类
	这样每个互斥变量都能保护与它关联的资源

	如果函数返回了资源的指针或引用，或者使用了由外界传入的可执行对象，那么即使锁住了互斥，也只能保证
	资源在本作用域内被保护，而资源在外界的读写处于未保护状态
*/