#pragma once
/*
	又称通用解题法
	可以系统地搜索一个问题的所有解。
	在包含问题的所有解的空间树种，按照深度优先的策略，从根节点触发，搜索解开建树
	算法搜索至任一节点时，总是先判断该节点是否包含于问题的解。
	如果不包含于，则不搜索该节点，而是进行回溯，
	如果包含于，则继续搜索该节点的子树。
	一旦找到一个解，就将其记录并寻找下一个解（也可以找到一个解就退出）
	直到所有节点都被搜索。

	回溯法的算法框架：
	1.定义问题的解空间。解空间一般是一张图，每个节点表示子问题的解。
	
	2.设计深度优先算法。从根节点开始，得到第一个子问题的解，然后将剩余问题作为
		一个整体，继续重复上面的过程。
		而当当前子问题无法得到解时，说明经这个子问题无法得到整体的解，于是回溯到
		上一个子问题，并以搜索该问题为父节点的下一个树节点（子问题）


	迭代式回溯：
	BackTracking(X)
	{
		k = 1;
		answer_num = 0;
		ElemType el[MAXSIZE];
		{初始化el数组};
		计算可选元素集合Sk;//假设Sk是带头节点的单链表
		el[k] = Sk的头节点;//el[k]先指向头节点，而不是第一个元素

		while(k > 0)//k大于0时一直迭代，直到k被回溯成0，说明所有解都找到
		{
			el[k]++;//el[k]先++，使其指向下一个元素
			while(el[k]无效)//遍历直到找到一个可用的el[k]
				el[k]++;//el[k]取下一个元素

			if(el[k]有效)
			{
				if(k == n)
				{
					answer_num++;
					//输出一个解 
				}
				else
				{
					k++;//去寻找下一个Xk
					计算可选元素集合Sk;
					el[k]=Sk的头节点;
				}
			}
			else
				k--;

		}
	}


	递归式回溯：
	形式：循环里面递归
		循环：遍历当前候选集合的所有可能
			选中一个元素后，修改或备份数据
			调用递归到下一层
			恢复已备份的数据
			去选中下一个元素
	RecursionBackTracking(X,k)
	{
		if(X={x1,x2,...,xk-1})//上一层递归是k-1，如果k-1已经得到解，输出即可
			输出X;
		else
		{
			计算可选元素集合Sk;
			Xk取第一个元素
			while(Xk不是最后一个元素)
			{

				//如果有全局的数据，在递归前备份
				Data_Backup = GlobalData;

				RecursionBackTracking(X,k + 1)
				
				//递归返回后，恢复数据
				GlobalData = Data_Backup;

				Xk指向下一个元素
			}
		}
	}
*/