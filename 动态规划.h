#pragma once

/*
	
	动态规划和分治法类似，也是将大问题分解为小问题。自底向上求解，最终得到原问题的解。
	对于某些特殊的问题，经分解得到的子问题往往不是独立的。
	分治法来求解这种问题，相同的子问题会被求解多次，以至于最后解决原问题耗费巨大的时间。
	如果能保存已解决的子问题的答案，再遇到重复的子问题时直接用已保存的答案，就可以避免大量重复的计算。
	用一个n维数组来记录所有已经解决的问题。


	动态规划算法常用于求解具有某种最优性质的问题。这种问题存在多个解，动态规划可以找到最优解，当然最优解可能也有多个

	动态规划的步骤
		1.找出最优解的性质，并刻画其结构特征
		2.递归定义最优解的值
		3.自底向上计算最优值
		4.根据计算最优值时得到的信息，构造一个最优解

		如果问题只要求最优值，第4步可以省略
		但如果要求最优解，需要用第4步比较多个最优值，从而找到最优解。这需要第3步保留计算最优值的信息

	动态规划适合解决具有以下两个性质的问题：
		1.最优子结构：如果一个问题的最优解种包含了子问题的最优解，则该问题有最优子结构。
		2.重叠子问题：递归调用去求解的子问题可能是新的，也可能是重复的。记录已经求解的子问题，并在遇到时直接读取



	动态规划的程序特点
		对于求解问题，有n个影响因素x1,x2,...,xn，记作S1，并记问题为Q(S1)
		该问题具有最优子结构和重叠子问题的特征，于是将问题分割成子问题，
		假设存在若干种分解情况，则根据实际做分支，得到影响子问题的因素的集合是S2,记子问题为Q(S2)
		S2是S1中至少一个元素减去k(向前直到0)

		然后在对子问题进行分割得到Q(S3)...,Q(Sm)，其中Sm={0,...,0}（n个0，表示所有影响因素都遍历到了0）

		实际程序中，先得到基于初始状态得到Q(Sm)的解，然后进行n重循环，得到Q(Si)的解，最终的到Q(S1)的解

		建立一个n维数组res，存放子问题Q(Si)的解

		初始化二维数组res

		双循环：外循环1到x，内1到y
			res[i][j]=1. res[i-1][j]
			          2. res[i][i-1]
					  3. res[i-1][j-1]
					  4......(或者+，-，*，/)
		
		不一定是以上3种情况，具体根据问题的需求

*/













