#pragma once
//默认成员
/*
	一个C++空类具有以下默认成员：
		默认构造
		默认析构
		默认拷贝构造
		默认赋值操作符
		默认移动构造
		默认移动赋值操作符
		默认&操作符
		默认const取址
*/

// 构造函数
/*
	默认构造函数
		没有参数的构造函数，默认初始化所有成员
		当创建数组或容器时，如果不使用初始化列表初始化，那么
		就会调用默认构造函数，对所有元素默认初始化

		全部参数都有默认值，会和默认构造冲突
			complex(){}
			complex(double re = 0, double im = 0): re(re), im(im) {}
			当创建一个无参变量时, complex a; 编译器将不知道该调用以上那个构造函数

	拷贝构造函数
		构造时，以一个同类对象作为参数，意图复制一个样本
		对象在值传递时发生的拷贝，也会调用拷贝构造

		拷贝构造分浅拷贝和深拷贝
		浅拷贝，即默认拷贝，按字节拷贝，指针会指向同一块地址
		深拷贝，由程序员定义，可以将指针所指的对象也拷贝一份

	私有构造函数
		外界无法生产该类的对象，只有该类自己的方法能生成。
		设计模式单例模式主要使用此方法实现


	子类调用父类构造
		子类构造函数会在【初始化自身之前】，隐含调用父类的默认构造
		如：
			Derived::Derived(...): Base(), ... {...}
		当然，也可以手动调用希望调用的父类构造
		如：
			Derived::Derived(...): Base(...), ... {...}


	重载new
		当使用new生成一个变量时，编译器会将代码扩展为三个步骤：
			一、分配内存，使用类的重载new（如果该类没有重载new，使用全局new）在堆上分配内存。分配完后会返回一个void指针
			二、指针转型，将void指针转为变量的类型
			三、指针调用构造函数。这是一种特别的语法。程序员不能通过指针调用构造函数，但编译器可以

		以上，说明构造函数负责成员初始化。内存分配的事由new或程序完成。
		即，先分配内存，后构造初始化

		operator new底层是调用了malloc
		重载operator new时，专注于分配内存即可，不需要担心类型转换和初始化

	POB与 trivial_constructor
		POB意味由简单基本类型（char、int、float）组成的类，如果包含指针，则不是POB
		POB的定义是递归的，一个由POB组成的类也是POB
		由于简单基本类型是没有构造函数的，因此POB类型的构造函数是trivial的

		但不代表有trivial_constructor的类就是POB
		POB是C的概念，不涉及C++的面向对象的特性。因此，含有继承和虚函数的类也不是POB
		因为继承的类的构造会调用父类构造，虚函数的类的构造会初始化虚函数表，都不是trivial

*/

//析构函数
/*
	没有指针成员的类，无需提供析构函数

	使用delete释放一个指针时，有两个步骤：
		一、调用指针指向的对象的析构函数
		二、调用operator delete释放指针指向的对象的内存

		和构造函数一样，指针调用析构函数也是只有编译器能做的。

		operator delete底层是调用了free
		重载operator delete时，只需专注释放内存，不需要担心对象成员的析构


	继承与析构
		
		子类虚构函数会在【析构完自身之后】，调用父类析构函数

		虚析构
			如果没有子类，或者只用变量，而不用指针（父类指针指向子类对象），则虚析构无关紧要
			首先要明确一点，构造函数、析构函数都是编译器调用的。
			在父类指针指向子类对象时，构造因为写明了子类，不会出现问题，
			但析构时，编译器只知道是父类指针而不知道指向地对象是什么类型，可能引发内存泄露
			当我们new一个子类对象，并用父类指针接收时：
				Base* p = new Derived();
			显然，编译器调用的是Derived的构造，而不会调用Base的构造。这是因为我们写明了要创建Derived对象，只不过用Base指针来接收
			但是析构时：
				delete p;
			编译器负责调用其析构函数，但是编译器并不知道，p指向Base对象，还是其子类的对象
			编译器只知道这是Base指针，因此编译器只会调用~Base()，也就是Base的析构函数
			而如果指向的是Base的子类对象的话，只释放了Base的内存，而没有释放子类的内存，从而造成内存泄露

			因此，必须要将类的析构函数用virtual修饰，利用虚函数多态机制，让指针正确地调用对应地析构函数
		 
*/

//this指针
/*
	对于类的一个对象，它的内存空间里存放该类的变量
	因为对于不同的对象，存放的变量是独立的。
	但是成员函数对所有对象都是一样的，因此不应、不需要在每个对象的内存里存放成员函数。
	成员函数作为该类名作用域的代码存放在代码区。
	那么如何根据不同的对象调用成员函数，正确地读写该对象的变量呢？

	实现的方法就是this指针
	所有成员函数都会隐含地传递this指针并且作为第一个参数。static和friend函数不会

	成员函数可以以对象来调用：
		a.func();
	也可以将对象作为参数，利用类目作用域来调用
		A::func(&a);

	第一种方法虽然没有参数，但编译器会将a的地址作为第一个参数
	而第二种方法可以看成是编译器眼里的成员函数的调用

	this指针也有利于虚函数在成员函数中的调用
	因为在成员函数里调用其他成员不会使用对象./->来，但实际上隐含的会使用this->来调用
	如果虚函数在成员函数中调用。由于this指针，虚函数会正确地被this所指的对象调用，从而调用子类复写的版本
*/

//const
/*
	const 修饰成员变量时，该变量为常量
	const 修饰成员函数时，该函数不能改变成员变量

	const对象只能调用const成员方法。
	class A{
		public:
		void func() {}
		void const_func() const {}
	}
	A a1;
	const A a2;
	a1.func();  //正确
	a1.const_func(); //正确
	a2.func(); //错误，a2是常量，只能调用const函数
	a2.const_func(); //正确

	以上，
		对于变量，根据其用途添加const
		对于函数，如果修改成员变量，不加const，除此之外，一切函数都应加上const

	对于两个完全一样的函数，一个有const修饰，一个没const修饰，视为两个不同的函数
		void func()const{}
		void func(){}
	以上，是正确的重载。即const可以作为重载的依据。
	原因：
		在程序员眼里，有没有加const，可能不影响函数的逻辑
		但在编译器眼里，它预设了没加const会修改成员，有加const不会修改成员（这一点从const对象只能调用const成员函数也可以看出）
		因此编译器认为，有无const的重载，它们的逻辑是不同的。从而认定是正确的重载

	但是这里有一个问题：
		一个成员函数有const和非const两个版本
		对于const对象，只能调用const成员函数
		对于非const对象，岂不是两个版本都可以调用？那样不会有二义性吗？

		当然是会的。所以编译器帮我们做了决定：非const对象只能调用非const版本。因为它预设了非const对象希望修改自己的成员
		例如：
			容器的[]重载，有const和非const两个版本。如果是const容器，只能调用const版本
			如果是非const容器，显然，[]取出元素后应该允许修改，因此，非const容器只会调用非const版本

	于是就有了以下的关系
		const对象调用const成员函数
		非const对象可以调用所有成员函数，但是对于有非const重载的，只能调用非const的版本

*/

//传值 or 传引用 ？
/*
	传值是拷贝数据再传递，传引用是将原本数据的别名作为参数传递。
	效率上，传值发生了拷贝，效率不如传引用。因此，应该尽量使用传引用而非传值。
	
	但并不一定都要传引用。
	在c里，传递一个很大的数据，可以使用传指针。实际上传指针也是传值。只不过是将指针的内容值传递给函数
	而指针是4个字节的，因此，当传递的数据小于4个字节时，传值快于传指针
	而引用实际上就是指针常量，因此引用其实也传递了4个字节
	因此，
		传递基本类型，或字节小于4的数据，传值
		传递更大的数据，传引用

	返回值同理，但返回值绝对不可以传递局部变量的引用

*/

//friend
/*
	friend可以访问类的私有、保护成员。因此存在外界改变私有成员的风险
	
	friend打破了类的封装，因此要慎用。如果可以通过公有函数获取，就尽量用公有函数
	除非能大幅优化性能，否则不用friend
	又或者，这个类设计出来就是给某个另外的类、函数来修改的。由此类、函数修改是安全可靠的
	那么可以为那个类、函数声明为friend

	两个同类的对象互为friend

	对于重载操作符，如果希望自身在操作符左边，应该是成员操作符重载；如果希望自身在操作符右边，应该是外部friend操作符重载
	例如：+=是成员重载，但+会设计为friend重载
*/

//指针成员
/*
	指针成员是非常重要的成员，直接区分了两种类的设计：
		有指针成员类
		无指针成员类

	拷贝构造
		编译器默认提供，按照成员的值逐个拷贝
		无指针类的拷贝构造用默认拷贝构造已经足够，但是有指针类不够
		指针成员指向一个对象，这种关系相当对类对象持有了一个对象
		换言之默认拷贝构造会使两个类对象的指针成员指向同一个对象。
		而当他们都析构时，就会对一个地址析构两次，而报错。
		因此，如果以持有者的姿态去拷贝，我们希望的是，复制一个持有的对象，并将自己的指针指向新的

	赋值操作
		对于赋值操作，默认的赋值只会按值赋值。
		对于有指针成员的类，
			一是会不再指向原来自己指向的数据，内存泄露
			二是和赋值的类对象指向同一个数据，可能会两次析构

		因此，对于有指针成员的类，其赋值操作符需要四个步骤
			检测是否自我赋值（此步骤必须，如果自我赋值，接下来会释放自己的指针，再根据自己的指针分配内存。而自己的指针已经被释放）
			释放自己指针所指的内存
			根据同类的指针分配内存
			根据同类的指针所指复制数据

	析构函数
		释放成员指针

*/

//静态变量与静态函数
/*
	静态变量存放在静态区
	静态变量对于类的所有对象是一样的。静态变量只有一份，所有类对象都可以读写
	静态成员在类实例化之前已经存在。因此，即便没有任何类对象，也可以通过类名作用域类访问（前提是该静态变量公有）
	如： A::static_var; //通过类目直接访问静态变量

	静态变量因为在实例化之前就已经存在，因此，不能通过构造函数初始化。
	静态变量应该在全局区（不在任何作用域之内）单独初始化，类内只做声明

	但是对于静态函数，只能操作静态变量，不能操作非静态变量
	因为静态函数也可以在实例化之间就调用。并且不会传递this指针
	因此静态函数只能操作类的静态变量
*/

//explicit
/*
	explicit用于修饰单参构造和类型转换操作符

	如果一个单参构造函数和类型转换操作符没有用explicit修饰，那么编译器会隐式地调用它
	如 A a = 1;//如果存在单参int地构造函数，此句成立
	int b = a;//如果存在转型操作符operator int 此句成立

	隐式调用有优点和缺点，有点是一个类对象的行为可以很像基本类型，代码更整洁
	但是缺点，是会产生歧义。

	如果存在，单参构造和类型转换都能满足一句代码时，
	例如： A c = a + b;  
		以上，如果定义了operator(const A&)
		那么既可以将b通过隐式单参构造转化为A类型，A = A + A
		也可以将a通过隐式int转换，再对加法的结果隐式调用单参构造，A = int + int
	编译器就会不知道如何调用而报错。
	因此，单参构造和类型转换两者中的一个应该修饰为explicit

*/

// 类指针类
/*
	类指针类的行为很像指针，主要是重载了*操作符和->操作符

	类指针类通常持有一个原生指针，并且再构造函数中分配内存，在析构函数中释放内存
	因此，此类对象离开作用域就会自动释放，比起原生指针需要使用者手动释放，要更加智能

	迭代器就是一种类指针类，并且还重载了++和--操作符
	迭代器针对它所迭代的容器专门设计，无论容器的数据结构有多复杂，
	外界只需使用++和--就可以遍历整个容器

*/

// 类函数类（仿函数）
/*
	类函数类的行为和函数十分相似，只需 对象名(..) 或者 类名()(...) 就可以调用函数


*/


//不能被继承的类
/*
	
*/

//更多细节
/*
	类型操作符：explicit operator int()const{...}
	初始化列表：A(...):...{}
	类指针对象
	类函数对象
	命名空间
	模板特化/偏特化
	标准库
	移动构造函数
	右值引用
	范围循环
	无序容器
*/

//
/*
	
*/