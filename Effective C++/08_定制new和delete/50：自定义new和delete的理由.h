#pragma once
/*
	为什么想要替换编译器提供的new和delete？
	一、定位错误
		只能手动使用，如果new而不delete，会内存泄露；如果多次delete会有不确定行为；new得了内存，却越界操作
		如果自定义new，便可在申请所需size的内存后额外神奇一块作为签名，并写入特定的值，在自定义delete检查签名是否正确
		对签名出错的指针进行日志
	
	二、特化应用场景
		编译器所提供的new和delete主要用于一般目的，它适用与长时间稳定运行的程序，也使用于瞬间完成的程序，它能胜任各种需求
		大块内存、小块内存、同时大小快内存。它都能适度地好，却没有最佳表现。如果程序申请内存地情况只有很少地几种
		那定制的new和delete会有更好地性能，有时能快数倍

	三、统计数据
		对于程序申请的内存，size如何分布？使用时长是多久？分配和归还是倾向于FIFO、LIFO，还是随机顺序？
		程序的最大内存水位是多少？通过自定义new和delete来获取统计数据，通过分析这些数据来对你的程序做对应的优化

	四、为了检测运用错误

	五、为了统计动态内存使用信息

	六、为了增加分配和回收的速度。对于特定类型设计的分配器会比泛用分配器有更快的速度，例如总是申请固定大小内存的类
		绝大多数容器都属于这一类，它们存放同类元素，只会去申请元素大小的内存，而stl对应使用pool分配器来加快速度
		如果你的程序是单线程的，那么可以抛去线程安全设计，这样可以大幅加快速度。
		当然，大多程序的优化瓶颈在于数据结构而非分配器。请在定制分配器之前确认你的程序瓶颈的确发生在内存上

	七、为了降低额外的开销。泛用分配器会对所需的size额外分配一些内存用以管理。这对大量且小体积的对象而言，会有相当多的内存被浪费
		参考stl的pool分配器来针对小体积对象容器

	八、最佳对齐。不同的类型有对应的最快访问速度的齐位。这通常是类型自己的大小（int是4bits齐位，double是8bits齐位）
		默认new并不保证当你为double申请内存时会把内存地址对齐到8bits的整数倍。这种情况下最好定制new

	九、使对象相拥成簇。某些数据对象往往会配合使用，因此如果被载入到同一页里，那么就会被同时命中，极大地加快速度
		为此，可以创建一个heap，并将数据对象在heap上创建。placement new能做到这种事情
		例如A和B是配合使用的，那么在new A时，在它的后面额外申请一个B大小的内存备用
		当new B时，如果它知道自己要和哪个A合作，那么使用Placement new在A后的内存上直接构建B
		这只是个简单的例子，聚簇对象有更复杂的设计但都是为了能提高合作对象的命中率

	十、非传统行为。在new和delete时机里，可能会有些额外地事务想要做，如前文提到的日志或统计。再如delete时将内存内容全覆盖为0以保证安全
		或者分配归还共享的内存
*/