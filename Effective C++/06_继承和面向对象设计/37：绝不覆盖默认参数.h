#pragma once
namespace case37
{
/*
	绝不覆盖默认参数，甚者，虚函数不要使用默认参数，而让非虚函数传递
	（由于绝不覆盖非虚函数，所以讨论的是虚函数的默认参数）
	如果父类指定了虚函数的默认参数，子类在重写时可以：
		1.不指定默认参数
		2.指定和父类不一样的默认参数
		3.指定和父类一样的默认参数

	默认参数并不属于函数声明的一部分，它只是编译器自动帮程序员填好参数
	一旦使用函数指针去调用函数，则必须填入参数
*/

void func(int i = 1);

// pfunc的类型是 void(int)
auto pfunc = func;

void test()
{
	func();//编译器自动填入默认参数
	pfunc();// 需要程序员手动填入参数
}
/*
	而虚函数恰好就是通过虚函数表里的函数指针调用的
	但是虚函数却支持默认参数。为何？
	因为虚函数与真正的函数指针不同的是它至少要通过一个对象来调用，因此可以和普通函数一样读取声明里的默认参数
	但是这个过程发生在编译期，因此即便子类不指定默认参数，或指定了新的默认参数，都是无法生效的
	因为只有运行时才知道对象的真正类型，因此总是填入父类的默认参数

	如果通过子类对象直接调用虚函数，则不是多态，因此会静态绑定子类的版本。此时
	1.子类不指定默认参数，则必须填入参数，父类的默认参数无效
	2.子类指定和父类不一样的默认参数，使用子类的

	对于3，如果父类修改了默认参数，则3就变成了2，所以2和3是同样的情况

	介于此，发现子类重写时指定或不指定都是不好的表现，会产生歧义，因此最好的解决办法是：虚函数不使用默认参数
	另外声明一个非虚函数，让它指定默认参数，并传参给虚函数
*/


}