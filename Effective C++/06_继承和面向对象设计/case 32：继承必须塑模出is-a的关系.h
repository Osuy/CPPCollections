#pragma once
/*
	确保public继承塑模出is-a的关系

	D public继承自B，代表着D是B的特殊化，B是D的一般化
	B对象能胜任某件事，或者符合某个情景，那么D对象也能胜任或合适
	但反之则不一定
	例如学生是人，人能吃东西，学生也能；学生去学校听课，而人则不一定符合

	任何子类都必定能够胜任父类，这是必要的严谨。
	例如：鸟会飞的语义是指所有鸟都会飞
	然而就我们所知的，并不是所有鸟都会飞，鸵鸟和企鹅就不会。
	因此如果将fly虚函数定义的基类Bird中，就默认了所有鸟都将具备飞行的能力

	更妥当的方案是派生出FlyableBird作为所有会飞的鸟的基类，其余不会飞的鸟继续以Bird作为基类
	然而这也只是稍微妥当而已，因为仅仅就一个会飞与否就增加了一层派生体系
	假若你的程序完全不在乎飞行，那便无需如此。能够适应所有需求的程序是不存在的

	另一种派别认为：承认企鹅会飞，但是那是一种错误
	让企鹅在重写fly函数是抛出错误

	当然还有一种最基本的做法，即不再Bird里声明fly，也不在企鹅里声明fly，只在那些会飞的鸟类里声明fly
	fly不是接口了，它只是一个普通成员函数并且有无数的鸟类具有这个同名函数

	以上三者的区别在于：一三会在编译器就报错，而二会在运行期抛出错误

	但假若遵顼着好的接口可以避免无效的代码通过编译，即便是第三中方案也比二要好

	再如：正方形public继承自矩形，而矩形具备一个能力，增加宽度从而增加面积
	但对于正方形而言，增加面积必须同时增加宽和高。正方形的宽和高不能独立修改，它们必须相等
	希望保持高不变，只增加矩形的宽从而增大面积，那么正方形就不能胜任

*/