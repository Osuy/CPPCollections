#pragma once

namespace case23
{
/*
	仅将需要直接操作成员的函数设为member，而把建立在直接操作上的间接操作设为同一个命名空间下的utils
	再将utils按照功能分散到各个文件中，将单个庞大的class分解为多个部分
	
	以no-member no-friend func代替 member func
	这可能反直觉，一个类对其成员的操作理应由它的成员函数来完成
	通过外部的函数来操作自己，有一点回归面向过程的味道。
	事实上，对于以下例子，外部函数反而具有更好的封装性
*/	
	class Test1
	{
	private:
		int a, b;
	public:
		void op_a() {} // 只操作a
		void op_b() {} // 只操作b
		void mfunc() { op_a(); } // 实现某个只操作a的功能
	};

	void gfunc(Test1& t) { t.op_a(); } // 实现某个只操作a的功能
/*
	如上，对于某个只操作a的功能，如果使用mfunc来实现，那么他无意中可能会不经过op_b而去操作b
	而使用gfunc，因为是非成员函数，只要保证不调用op_b，它就无法操作b，因为那是private成员
		
	试想，成员函数能够访问所有private成员。实现一个单纯只操作某些private成员的函数在初期或许可以保证，
	而一旦程序变得复杂，或者经手他人，那么极有可能撕毁条约，访问无关的private
	实际开发中，一个类的private成员往往是繁多的。而使用者可能只关心其中的某一部分
	如果使用成员函数去完成某个功能，那么所有private就都对其开放，反而破坏了封装

	于是，可以把对成员的操作分为三种：直接操作、间接操作、混合操作（既有简洁操作也有直接操作）
	那么请尽可能地把间接操作声明为no-member no-friend函数

	即：class将操作成员的函数声明为成员，将单纯涉及到某一方面的函数声明为utils

	值得一提的是：class的定义必须是完整的，而namespace可以分散到多个文件中
	于是可以将class和utils声明在同一个namespace中，但是却放在不同的文件里
	大大降低了单个文件的复杂度，将不同的功能分散到不同文件中，方便组织和调试
*/
}