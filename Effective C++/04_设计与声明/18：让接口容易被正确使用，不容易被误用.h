#pragma once
#include <memory>

namespace case18
{
/*
	容易被正确使用
		1.拟合基本类型行为
		2.接口一致
		3.接口声明引导用户
	避免被错误使用
		1.类型检查约束
		2.将更多职责于自己负责而非使用者
	
	如果一个接口被用户认为可以这样用，但实际上这样用会出错，那么接口的设计就不合理
	要让用户能从接口中很容易地获取到使用方式
	而如何正确的使用前提必须是“用户要记得做某事”，那就是存在误用风险的
*/

	class Date
	{
		Date(int month, int day, int year);
	};

/*
	以上，使用了参数名提示使用者应该输入何种数据。虽然有一定的提示，但却未能防御错误的使用：
		1.顺序错误，因为虽有提示，却无约束
		2.数值范围错误，对month输入超过12的数值，3就在2旁边，敲错按键也有可能
		3.在debug时由于失去了参数名，而不得不查看声明

	C++是强类型语言，类型检查是把错误拦截在编译阶段的最好帮手
	对日、月、年定义各自的类型是更好的做法
*/
	struct Month;
	struct Day;
	struct Year;
	class Date2
	{
		Date2(const Month& month, const Day& day, const Year& year);
	};

/*
	日期和年份是不易约束的，但是月份只有12个，容易建立约束
	或许你想到使用枚举，但即便是enum class 强类型，也不能阻止13强转为month
	不让用户产生一个奇怪的month，那干脆先把所有month定义好，然后把构造声明为private
*/
	struct Month
	{
		static Month Jan() { return Month(1); }
		static Month Feb() { return Month(2); }
		// ...
	private:
		Month(int);
	};

/*
	除了类型检查，另一个预防错误的良计：将类的行为设计得和基本类型一致
	这是为何？因为用户无法记住所有类的行为：类型A的行为如何如何，类型B的行为如何如何
	假使有一天错把B的印象串联到A上，就是发生错误的征兆。
	而几乎不会把基本类型的行为记错，因为它们已经就是和数学工具的行为一致的
	当然，与基本类型行为一致的好处不仅仅是避免误用，它也极大地增加了接口被正确使用的概率
	很少有其他性质比“一致性”更能让“接口被正确使用”
	也少有其他性质比“不一致性”更能让“接口被错误使用”
	STL的接口十分一致，所有容器都有size函数来告知容器内元素的数量
	而Jave的不同容器有不同的方式：length、count，设置size成员变量

	此外如果正确的使用前提必须是“用户要记得做某事”，那就是存在误用风险的
	例如函数的返回值是一个指针
*/

	int* creat_ptr();
/*
	它返回一个指向动态内存的指针，并寄希望于使用者delete
	那么就直接造成了两种可能的错误：用户并未delet，或用户多次delete
	用户的最佳处理方式是用智能指针来管理自动delete
	但何不由函数先发制人，直接返回智能指针？以应对用户的疏忽
	同时由于返回的是智能指针，返回值是否是数组首地址的疑虑也消除了
*/
	std::shared_ptr<int> creat_ptr(int);
}