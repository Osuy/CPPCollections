#pragma once
#include <iostream>
using std::cout;
using std::endl;

namespace case12
{
	/*
		编译器提供的默认拷贝构造和赋值本就是完美地复制，它会自动调用类的每一个成员的拷贝构造和赋值
		对于继承，它们也会调用父类的拷贝构造和赋值
		假如你非要自定义拷贝构造和赋值，那么你需要留意：
			1.即便你没有拷贝所有的成员，也不会有错误和警告。因为你自定义了，所以编译器只会认为你不希望拷贝它们
			2.对于新增加的成员，你要根据需要同时在拷贝构造和赋值里去添加对应的代码。如不增加，视为情况1
			3.子类的拷贝构造需要显式调用父类的拷贝构造，如果不写，则会调用父类的默认构造，那样的结果就是
				父类的部分是默认值（因为它们被默认构造初始化了），子类的部分是拷贝的值
			4.子类的赋值需要手动调用父类的赋值。如果不写，则视为不希望拷贝父类的部分

		于是你会发现，自定义拷贝构造和赋值，只会带来更多繁重的事。然而那是你自定义的代价。
		一旦你自定义了，编译器会认为你希望完全接管。而它如果做任何事都会是多余的，都会成为对你的限制，所以它什么都不做
		（可见默认的构造和赋值其实做了相当多的事，只是它们的代码你无法看见）

		需要自定义拷贝构造的情况无非两种：
			1.不希望拷贝某些成员
			2.希望深拷贝某些成员

		如果让这两种成员与其他希望常规拷贝的成员处于同一个类，那么该类不得不自定义拷贝构造和赋值
		假使常规的成员很多，并且需要修改，那么连带的拷贝构造和赋值也成为了必须要修改的对象
		因此更好的做法是：
			把这两种特殊成员封装一下，而原本的类不自定义拷贝构造和赋值
			这样普通成员的复制就不受影响
			然后对于封装了不希望拷贝的成员的类，自定义空拷贝构造和空赋值，于是它不会被拷贝
			对于封装了希望深拷贝的成员的类，自定义分配内存的拷贝构造（自定义赋值可以参考case11）

	*/


	struct A
	{
		A() 
		{
			cout << "A::default constructor" << endl;
		}
		A(const A&)
		{
			cout << "A::copy constructor" << endl;
		}

		A& operator=(const A&)
		{
			cout << "A::assignment operator" << endl;
			return *this;
		}
	};

	// 全默认情况 子类的X调用父类的X
	struct B : public A {};

	// 显式声明了拷贝构造，但是设为预置。行为和B一样
	// 显式声明了赋值操作符，但是设为预置。行为和B一样
	struct C :public A
	{
		C() {}
		C(const C& other) = default;
		C& operator=(const C& other) = default;
	};

	// 显式声明了拷贝构造，但是初始化列表没有对应的父类拷贝构造
	// 于是D的拷贝构造调用A的默认构造，即仅复制了子类部分，父类部分是由默认构造初始化而来的
	struct D :public A
	{
		D() {}
		D(const D& other) {}
	};

	// 显式声明了赋值操作符，但是没有调用对应的父类的赋值
	// 于是E的赋值没有复制父类部分
	struct E :public A
	{
		E() {}
		E& operator=(const E& other)
		{
			return *this;
		}
	};

	void test()
	{
		B b1;
		B b2 = b1;
		B b3;
		b3 = b1;
		cout << endl;

		C c1;
		C c2 = c1;
		C c3;
		c3 = c1;
		cout << endl;

		D d1;
		D d2 = d1; // D的拷贝构造使用了A的默认构造
		D d3;
		d3 = d1;
		cout << endl;

		E e1;
		E e2 = e1;
		E e3;
		e3 = e1; // E的赋值没有调用A的赋值，所以会少打印一行
		cout << endl;
	}
}

class A
{
public:
	A() = default;
	A(const A&) = delete;
};

class B : public A
{
public:
};