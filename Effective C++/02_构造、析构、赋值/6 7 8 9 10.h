#pragma once

/*
	case 6：将不希望被使用的默认函数声明为delete或private
		对于默认函数如果不希望它们被外界，可声明为private（如单例，外界不可构造、拷贝、赋值、移动，但static成员可以）
		如果希望绝对不能用，可以弃置默认函数 = delete
	
	case 7：为多态基类声明virtual析构
		如果一个基类的析构函数不声明为虚函数，那么当delete 一个基类指针，而这个指针指向的是一个子类对象是
		delete只会本本分分地把父类的部分回收而无视子类的部分，于是子类的部分就发生的内存泄漏

	case 8：析构函数不要爆出异常
	
	case 9：不要在构造和析构内使用多态
		如果一个虚函数非要被子类重写不可，或因特化逻辑，或因使用子类的成员
		而在父类构造函数期间，子类的成员变量未初始化
		如果虚函数使用了未初始化的变量，结果是未知的，所以C++在语言层面阻止了这种行为
		对于析构函数，也是同样的道理，父类的析构晚于子类的析构，此时子类的成员变量已经析构
		所以使用已经析构的变量，结果也是未知的
		在父类构造、析构期间的所有虚函数都会直接链接为普通函数，也就是父类自己的版本
		如果真的需要子类参与到父类的构造过程中，可以使用父类的有参构造，向其传递参数
		（也有一说虚函数表未在子类构造函数前初始化，但那不是真正原因）

	case 10：赋值操作符返回*this
		如下声明一个赋值操作符
		T& operator=(const T&){ ... return *this; }
		它支持链式赋值
*/