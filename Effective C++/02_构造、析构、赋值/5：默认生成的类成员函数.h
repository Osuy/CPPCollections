#pragma once

namespace
{
	/*
		编译器会为类提供一些默认函数，即使没有显式声明它们
			默认构造（如果没有声明任何构造）
			默认拷贝和赋值
			默认析构
			默认移动和移动赋值（C++11以后）
	*/

	class test
	{
	public:
		test(int) {}// 因为存在用户声明的任何一个构造函数，所以没有默认构造
		// 如果没有这个函数，还会提供默认的无参构造

		// ~test(){}
		// test(const text&){}
		// test& operator==(const text&){}
		// test(text&&){}
		// test& operator==(text&&){}
	};

	/*
		上文的默认函数只会在被有被使用的情况下提供，如果程序中没有使用，则也不会提供

		类成员的初始化和析构，这些流程都是需要有对应入口的
		虽然没有任何相关的代码，但是最终编译器生成的机器语言，需要执行这些流程
		而它们的最佳入口就是类本身的构造和析构，切确的讲是：构造之前的初始化和析构之后的类成员析构
		提供默认函数的原因是给必要的流程提供藏身之处。

		而拷贝构造和赋值，也是为类对象的拷贝和赋值等基础行为提供支持，使其能更自然地被使用

		但是当类内存在const或引用变量时，不会提供默认赋值。
		因为对于已经初始化好的const或引用变量，赋值无疑会去修改它们。然而const变量不能被修改，引用也不能修改其所指的对象
		类似的，如果父类的赋值是私有的，子类也不会有默认赋值

		默认提供的函数，只是为了给类提供一个最低程度可用性，而无需用户对每一个类都书写相似度极高的代码
		但是假如这些行为取决于用户自身的特殊意愿，例如上文的const或引用成员、父类的私有赋值
		则该如何赋值已经说不清楚，只能让用户自己去决定，编译器选择放弃
	*/
}