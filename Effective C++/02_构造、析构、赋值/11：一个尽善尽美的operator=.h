#pragma once

/*
	省流：
		1.考虑自我赋值
		2.考虑new异常后指针依然有效
		3.考虑局部变量的拷贝构造代替new，析构函数代替delete，swap来交换指针
		4.形参传值拷贝来优化局部对象拷贝
	
	一个operator=本身就有足够多的事情要做。
	你可能认为它和拷贝构造差不多。但是至少有一个明显的不同是：
		拷贝构造时，“我”还未存在，“他”已存在。而赋值时，“我”和“他”都已存在
		因此存在一种可能性，就是“他”赋值给了“我”，即自我赋值

		T a;
		a = a;
		虽然很可笑，但这样的行为是合法的。而且有时候，这样的可笑行为也不一定就能被发现
		例如T a[];
		a[i] = a[j];// i==j
		亦或者是指针赋值
		T a;
		T* p1 = &a;
		T* p2 = &a;
		*p1 = *p2;
		以上，自我赋值都可能在我们尚未察觉的是否发生

	然假若operator=与拷贝构造所做的事一样，那么首先的一个问题就是：动态内存成员错误释放
		T& operator=(const T& other)
		{ 
			if(_p)
				delete _p;
			_p = new TB{ *other._p };// _p已经被delete了，此时new TB{ *other._p }使用了野指针，产生未定义行为
			return *this; 
		}

	最简单的解决办法是加一个判断：
		T& operator=(const T& other)
		{
			if(this == &other) return *this; // 自我赋值时不做事
			if(_p)
				delete _p;
			_p = new TB{ *other._p };
			return *this;
		}

	然而当 new本身抛出了异常时，由于原先的_p持有的内存已被delete，已经无法回退
	虽然更安全的版本应该是 会写上_p = nullptr;
	但是无论如何，一个赋值操作的结果可能会是赋值失败并且自己原有的内存也失去了，显然不够合适
	可以再做如下的修改：
		T& operator=(const T& other)
		{
			auto old_p = _p;
			_p = new TB{ *other._p };// 如果new失败，_p原封不动
			delete old_p;// new成功，把旧内存释放掉
			return *this;
		}

	并且你注意到这个写法也能处理自我赋值。只不过它比起自我赋值什么都不做的写法
	它无论是正常赋值还是自我赋值，都会发生new
	不过自我赋值本就是极少的情况，哪怕多new一次，也不会比常规的差多少

	在讨论具有动态内存的对象的赋值时，不妨考虑已经我们已经有的东西。
	一个持有动态内存的类，一定也有合理设计过的拷贝构造。而调用拷贝构造时，“我”并不存在，也就只需关心动态内存的复制
	此外，还有一个释放持有动态内存的析构函数。如不设计，则明显存在内存泄露的问题。
	下文的版本的赋值，就运用以上二者：
		T& operator=(const T& other)
		{
			auto tmp = other; // 利用拷贝函数创建一个局部对象，动态内存复制的事交给拷贝构造去做
			swap(tmp); // 自己与局部对象互换持有的动态内存
			return *this; // 然后tmp在离开作用域时会自动析构，把旧的内存给释放调
		}

	这是一个较好的改写，虽然它要求类需要实现一个swap函数。但是多一个swap本身不是累赘，而且也有合适的作用
	优化的最后一步，可有可无，就是将赋值的传参改为传值，这样，进入函数时便会自动拷贝
		T& operator=(T other)
		{
			swap(other);
			return *this;
		}
		
*/