#pragma once

namespace case43
{
/*
	一言以蔽之：子类无法直接使用类模板基类的成员
	原因：类模板可以特化，所以子类不能假设父类的拥有任何成员
	
	类派生自一个未确定模板参数的类模板时，其基类的成员无法直接使用
	可能的两个原因：
		一、降低代码膨胀
			这关系到类模板和模板实例化
			首先对于一个类模板，其所有成员函数都是函数模板。而对于函数模板，只有其被调用过才会具象化出具体的代码
			因此对于一个有100个函数的类模板，如果只用过一个成员函数，那么具象化的代码也就只有一个函数
		
		二、类模板全特化
			如果存在匹配的全特化版本，可能成员完全不同，可能不存在这个函数

	如果希望调用，方法有三：
		一、this->调用，提示编译器在自己或父类的命名空间寻找函数
		二、using父类的函数名，告诉编译器该函数位于父类命名空间
		三、用父类::函数名(...)的方式调用，告诉编译器调用的是父类的函数

	第一种调用方式不会多态
	谨记，模板的所有指针调用行为都是编译器确定的，早绑定，不会多态
	模板的多态是基于标识符的，不同类的同名函数具象化后的多态

*/

template<typename T>
class Base
{
public:
	void func() {}
};

template<typename T>
class Derived : public Base<T>
{
public:
	void func2() 
	{
		// 此处无法使用func，虽然没有错误提示，但编译不通过
		// 因为继承自Base<T>，虽然Base有func成员，但当Base<T>是一个特化版本时，不一定有func成员，所以不能直接使用任何父类的成员
		//func();

		// 1.通过this调用，查找自己和公有继承的父类的命名空间
		this->func();

		// 2.用using指明func在父类命名空间里，再调用
		// using 语句也可以写在类命名空间里
		using Base::func;
		func();

		// 3.通过父类命名空间前缀调用
		// 发生静态绑定，如果func是虚函数将无法多态
		// 方法2可以多态是因为调用func()并没有强制指定父类命名空间
		Base<T>::func();
	}
};

}
