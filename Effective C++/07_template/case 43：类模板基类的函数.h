#pragma once
/*
	类派生自一个未确定模板参数的类模板时，其基类的函数无法直接使用
	public继承的子类命名空间包含父类，但对于未确定模板参数的类模板基类，不会包含基类命名空间
	
	可能的两个原因：
		一、降低代码膨胀
			这关系到类模板和模板具象化。
			首先对于一个类模板，其所有成员函数都是函数模板。而对于函数模板，只有其被调用过才会具象化出具体的代码
			因此对于一个有100个函数的类模板，如果只用过一个成员函数，那么具象化的代码也就只有一个函数
		
		二、类模板全特化
			如果存在匹配的全特化版本，可能成员完全不同，可能不存在这个函数

	如果希望调用，方法有三：
		一、this->调用，提示编译器在自己或父类的命名空间寻找函数
		二、using父类的函数名，告诉编译器该函数位于父类命名空间
		三、用父类::函数名(...)的方式调用，告诉编译器调用的是父类的函数

	第一种调用方式不会多态
	谨记，模板的所有指针调用行为都是编译器确定的，早绑定，不会多态
	模板的多态是基于标识符的，不同类的同名函数具象化后的多态

*/