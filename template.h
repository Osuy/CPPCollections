#pragma once

/*
	类模板与函数模板
	当一个类的某个成员，或函数的参数、范围值，其类型目前尚不确定，或其可以有广泛的类型
	那么可以将类、函数设计为类模板、函数模板

	类模板
		必须显式指定模板参数
		可以特化、偏特化

	函数模板
		可以隐式调用，会自动类型推导
		特化和偏特化无意义。因为可以重载，优先调用重载的函数，
		通过添加模板参数来显式调用
*/

/*
	类模板

	成员函数模板、构造模板
		类模板可以拥有成员函数模板，其模板类型必须和类模板的模板参数不同
		由于函数模板会在使用的时候类型推导，因此，成员函数模板无需，也不能与类模板系统
		例如
			teplate<class T> class A
			{
				void func1(T);// 常规成员，会在类指定模板参数时确定下来

				template<class T>
				void func2(T);//错误，与类模板的模板参数相同，会在类指定模板参数时确定下来

				template<class U>
				void func3(U);//正确，与类模板的模板参数不同，会独立推到
			}
		模板构造是最重要的模板函数。模板构造意味着，对于该类，可以使用其他类型进行构造
		此间会发生类型转换，因此可以用能够互转的类型（float转int、子类转父类）来构造
		例如：
			class Base1{};
			class Derived1 : public Base1{};
			class Base2{};
			class Derived2 : public Base2{};

			//模板构造允许用其他类型来构造自身，会发生类型转换
			//可以将子类向上转型为父类，然后构造
			std::pair<Base1, Base2> p( std::pair<Derived1, Derived2>() );

		除模板构造外，模板操作符，或者其他希望支持广泛参数的函数，都可以设计为模板函数


	类模板成员（也称模板模板）
		一个类模板，它的一个成员变量可以是类模板。
		但是，直接用类模板做成员或未定类型，实际上是确定下来的。
		我们希望的是成员类模板本身也要未定。由于类模板必须显式指定模板参数，因此未定的成员类模板必须由类模板来声明
		即模板参数本身也是一个类模板，才能允许成员是这个类模板
		例如
			template<class T, 
					 template<class U>
					 class Container   > 
			class A
			{
				T a; //普通成员
				vector<T> b; //虽然是类模板，但也是普通成员，因为vector自身是确定的
				Container<T> c; //真正的成员类模板，Container和T都是未定的
			}
			

	全特化
		对于一个泛用的类模板：
			template<class T> class A {...};
		它接受多数类型时，用相同的一套逻辑，但是我们希望当它接受某一特殊类型时，有不同的逻辑。以int为例：
			template<> class A<int> {...};
		其中，模板声明还在，但不再写未定类型，而是在类名后面加上 <[指定的类型]>
		然后对int做独特的处理。当我们定义一个A<int>变量时，不再走类模板，而是走特化后的类
		这和继承多态很像，但特化后的类与类模板除了名字，没有任何关系


	偏特化
		偏特化就是特化了，但没完全特化的感觉
		偏特化有两类，一是个别偏特化，二是范围偏特化
		个别偏特化很好理解，就是对于有多个模板参数的类模板，使其个别模板参数特化
		例如
			template<class T1,class T2> class A{};
			template<class T> class A<int,T>{};
			以上，有两个模板参数，对第一个特化为int

		范围偏特化对模板参数没有要求，一个或多个都可以，偏特化的参数，会依赖自身，或其他参数
		例如
			template<class T1, class T2> class A <T1*, T2>{};	//依赖自身，将T1偏特化为T1*，表示第一个参数如果是指针，就使用这个版本
			template<class T> class A <T, T>{};		//依赖其他参数，将两个参数特化为一个，表示如果接受两个模板参数是一样的话，就使用这个版本 

*/