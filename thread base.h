#pragma once
/*
	atomic
		顾名思义，原子的，不可分的。指原子操作
		确保多个线程在访问一个全局资源时，同一时间内只有一个资源能够访问
		以往对于临界资源的访问，都是使用锁来实现
		C++11的atomic从更底层的编译器层面保证了共享资源被访问时的互斥性。有效减少锁的使用，更为高效

		当有多个线程访问同一个资源时，优先使用atomic而不是锁
*/

/*
	mutex
		互斥量，用于实现临界区或临界资源。禁止拷贝与move，只有默认构造，初始化时处于unlock状态
		lock()：上锁。当已被其他线程上锁时，会阻塞本线程直到成功上锁。
			注意：如果本线程已经上锁，再次上锁就会出现死锁
		try_lock()：上锁。相比于lock()，当互斥量已经被其他线程上锁时，不会阻塞本线程而是直接返回false。
		unlock():解锁

	recursive_mutex
		递归互斥量。允许一个线程对互斥量进行多次上锁。但同样需要多次解锁。
		相当于对一个互斥量有多层次的互斥访问。用于嵌套临界区，避免声明多个互斥量

	time_mutxe
		计时互斥量。相比于mutex，多了try_lock_for和try_lock_until两个函数
		try_lock_for：设置等待时间，超过这个时间，返回false
		try_lock_until：设置等待时刻，当超过这个时刻，返回false

	lock_gurad
		锁护卫。手动使用mutex的lock和unlock，就如同new和delete一样，必须配套，但又容易忘记。
		因此，所护卫就是用来自动解锁的。相当于智能指针，当离开作用域时就会自动解锁
		构造函数接受一个mutex，就能自动上锁。离开作用域自动解锁

	unique_lock
		通常于条件变量配合使用
*/

/*
	condition_variable
		条件变量。线程间通信的工具，负责阻塞和唤醒。顾名思义，需要一个条件来觉得本线程的阻塞或继续。
		当一个线程的继续执行需要其他线程释放或生产出某些资源时，可能会出现一种情况：如果没有资源，那么就必须一直等待
		以往，实现一直等待就是直接用死循环。但是这样会不停占用cpu，效率低下。阻塞和唤醒就可以完美适用此情况。
		因为资源被释放或生产出来的时机，就是该线程应该继续执行的时机。因此，可以让该线程阻塞，如果有谁生产或释放了资源，就通知哪些被阻塞的线程
		从而避免使用死循环来等待。这就是条件变量的思路。
		其最重要的是wait和notify。
		
		wait，接受两个参数，一个unique_lock，一个条件判断函数
			因为是最对临界资源的操作，前文一定已经创建了一个锁
			但是由于临界资源可能为空，上锁之后又阻塞会使其他线程不能获取到锁。因此wait会先解锁，再阻塞本线程
			那如何知道临界资源是否为空呢？这就是条件判断函数的作用。
			如果条件判断函数返回true，说明可以继续执行，那么wait什么也不做
			如果返回false，说明不能继续执行，wait会解锁并阻塞自身，直到有其他线程调用notify，wait会再次上锁
			（因为wait会自动解锁，被唤醒时又自动上锁，因此需要把锁作为参数传进来）

		wait_for，设置阻塞时长，如果超过指定时长还没被唤醒就会自动唤醒
		wait_until，设置阻塞时刻，如果超过指定时刻还没被唤醒就会自动唤醒

		notify_one，随机唤醒一个被wait阻塞的线程。如果没有被阻塞的线程，则不做事
		notify_all，唤醒所有被wait阻塞的线程。如果没有被阻塞的线程，则不做事
*/

/*
	function
*/

/*
	future
*/

/*
	result_of
*/

/*
	
*/