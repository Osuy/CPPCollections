#pragma once
/*
	可变数量的模板参数
	首先思考一个问题：
		cout流式输出，用户写多少个数据就输出多少个数据，
		这中间是因为每次输出都返回ostream，从而继续下一次输出
		但是printf是函数，要输出的数据以参数传给printf
		那么它是如何做到可以接受任意数量的参数的呢？

	C++11增加了一个关键字：...
	它能够帮助函数模板实现接受任意数量的参数（类模板不能）
	用它来修饰模板参数和函数参数时，编译器不会对参数进行类型推导，并将所有参数打包为一个
	...的书写位置类似指针和引用，如果已经有指针和引用，写在它们后面
	
	如果将打包好的参数传给能够推导第一个参数的函数，那么会推导第一个参数，然后剩余的参数打包视为一个
	如果是递归调用，那么可以实现逐个推导的效果，最终推导出所有参数
	那么最后一次调用是0个参数，因此还需要一个0参数版本，空实现即可

	总结：
		函数模板 + 第二参数... + 递归调用 + 0参数空实现版本 = 可以处理任意数量任意类型参数的循环

*/

//接受任意数量参数的print，会推导第一个参数
template<typename T,typename... Types> // 修饰模板参数
void print(const T& firstArg, const Types&... args) // 修饰函数参数，不做类型推导。对第一个参数推导后，剩余全部视为一个
{
	sizeof...(args); // sizeof...()返回参数的数量
	//std::cout << firstArg << std::endl;
	print(...args); //剩余参数再次调用，会对第一个参数推导，然后再将剩余的打包
}

//0参数版本，空实现
void print() {}