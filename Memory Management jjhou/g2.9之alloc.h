#pragma once

/*
	内存管理无外乎：减少分配内存次数；增加效率

	维护一个free_list，其长度为16，每个元素代表着长度为8的整数倍的可用内存
	即 8、16、...、120、128
	对于超过128字节的类，malloc的cookie并非吃紧，于是直接分配即可
	而对于以上的小型类，从free_list中取用更为高效和节约

	欲申请N个字节，从N对应的链表开始寻找有无可用的内存
		有：头删法取出第一个可用内存

		无：备用池是否大于等于N
		
			有：从备用池中尽可能多（但是至多20）地从备用池中取出N的倍数个大小的内存，切割为每份为N的若干块，其中一块返回，剩余串为链表置于N链表下
				（此时备用池的剩余容量小于N，面对下次的申请，如果小于N可能满足，如果大于等于N则一定不满足。也就是下面这条分支）
			
			无：若备用池有剩余，将整个挂置到其对应的链表下（备用池小于N说明不足128，但是一定会是8的倍数，所以能对应free_list的某个位置）
				申请 2* 20 * N + 上调数 大小的内存，这个申请操作使用::operator new 或 malloc ， 是带cookie的
			
				申请成功：其中取 20 * N 大小的内存，切割为每份为N的若干块，其中一块返回，剩余串为链表置于N链表下
					剩余给到备用池（备用池有剩余的话已经给到对应链表了，此时总是为空，备用池不是链表，是一整块内存）
				
				申请失败：说明系统内存耗尽，备用池也不够用，只能向靠后面链表寻找空余的内存
				
					存在空余内存：切割为一个N和剩下的8的倍数的内存
						剩余的8的倍数的内存可以放到相应链表；返回切出的内存
					
					不存在：山穷水尽，终止程序

	问1：虽然走到了山穷水尽，但是往前的链表可能还存在空余，是否能合并得到可用的内存呢？
		因为结构是链表，申请和归还的顺序是随机的，因此即便前面的链表里存在的空闲内存的合计值可能大于N
		但是他们在物理内存上可能不连续，也就无法合并。而设计合并算法的难度极大，市面上没有任何分配器做这样的事

	问2：申请的是2* 20 * N + 上调数 大小的内存，这个值很大。系统的可用内存小于它，但可能仍大于N，是否可以将其缩小并再次申请呢？又或者直接申请N？
		到这种地步，关心的应该是释放内存，而非继续榨干系统以致系统崩溃
		所以也没有分配器这么做

*/