#pragma once

/*
	malloc 也具有内存管理的功能，比之pool_allocator更为复杂
	其中最重要的一个设计是cookie。cookie的作用是用于合并内存块
	而pool_allocator费尽心力去除了cookie，因此自然也丧失了合并内存的能力

	对于超出1024的申请，malloc也仅仅只是直接调用系统的api去分配
	而对于小于等于1024的申请，由sbh（small block heap）来管理

	其内容复杂庞大难懂，因此只简要介绍
	首先sbh会向系统申请 1M 的内存，这个动作和 pool_allocator 的申请2*20*size的大块内存 的意图一样
	都是申请一块大的内存给自己来慢慢用，以减少系统api的调用次数
	对应这1M的内存，会有16*32个数据结构group来管理。每个group管理32k的内存
		32个group
			分配回收数值之差，如果为0，说明内存皆在手中（已全部归还）
			2*64个链表指针，每两个指针维护一个链表，从16开始至1024（1024以上的也由1024管理）
			一个64位bit，记录group里的每个链表的内存的有无（链表指针即使没内存也会指向group的首地址，用意不知）

	起初32k的内存被分为8页，每页4096，其中会在首尾填充各4字节的0xffffffff，并下调到16的倍数，于是实际可用大小为4080
	4080字节的内存页里的前12个字节存放：内存页当前的可用大小（初始4080）、前页指针、后页指针
	8个内存页会被串成链表，交给最后一个group，即63号group，并标记第64个bit为1，表示63号group有可用的内存

	为什么size、前页指针、后页指针在4080字节内存内部？
		只有空闲的内存块才被sbh管理，因此可以借用12个字节来存放这些数据
		假如内存块分毫不剩都被分配出去了，那么这12个字节也就被用来填入数据了
		由于最小的链表也是16字节，所以取12个字节来用是足够的

	当malloc申请的内存小于等于1024时，会进入到sbh中寻找，假如size为512，那么就会去512 / 16 = 32 即31号链表中查找
	如果没有就继续向后查找，直到找到有可用内存的链表
	然后去取出第一块内存，从尾部删去512个字节，剩下的内存插入到对应的链表里
	
	这512的字节是已经经过计算的，包含cookie、debugheader、nomanland、panding。
	实际上会给程序的内存是其内部的更小的一块。（程序员向malloc申请N，经过计算后需要512，再向sbh申请）
	然后就是设置 cookie、debugheader、nomanland
		debugheader的作用就是调试
		nomanland相当于栅栏，填充0xfd，对它读写会引发未定义行为
		cookie在首尾各有一个，数值是 0x20 = 512，记录这块内存的大小
			由于是16的倍数，所以最低4字节一定是0，于是将最低一位的bit用来表示其是否空闲

	将首位的cookie的最后一位置1，表示被使用，然后将内存指针return
	而调用free释放时，可以根据size找到对应的链表并插入，取cookie内的前12个指针，填入size、前页后页指针
	注意cookie并不会被视为可用内存，它依然会保留，并记录这块内存的大小，并且最后一位会被置0
	为什么还要用cookie记录内存大小？
	你可能会觉得，我把内存块放入到某个链表了。完全可以通过这个链表是几号来计算出内存块的大小
	没错。从链表得到内存块的大小，这是正向获取.但是还存在希望通过内存块直接获取大小，并计算出几号链表的情况，这是逆向获取
	但是在插入到链表前，可以试着进行合并，这也是cookie的作用
	
	为什么cookie可以用来合并内存？
		结合上文，所有从sbh内申请而来的内存都在内存页中，被0xffffffff包围
		而所有内存块又被cookie包围，所以一个内存块的相邻前后两个字节无非就是栅栏0xffffffff，或者其他内存块的cookie
		而0xffffffff的末位是1，恰好会被视为是被占用，所以是不会和栅栏进行合并的
		那么就只有当前后出现了末尾是0的cookie，就说明是可以合并的
		于是，上cookie就用于向下合并，下cookie用于向上合并

	合并
		由于cookie记录了内存块的大小和使用情况，那么就可以通过
		当前指针 + 内存大小获取到下方内存的上cookie
		当前指针 - 4 获取到上方内存的下cookie
		如果上/下方内存空闲，说明可合并，把它从链表里移除
		然后将大小相加，得到新的合并后的大小，写入到新的首位cookie里
		再根据新的大小计算并插入到对应链表

	前文的free还有非常重要的事没有提。
	一个内存块固然可以通过size计算出应该还给几号链表，但是shb有16和header，每个header又有32个group
	如何知道内存该还给那个header的哪个group呢？
	首先内存块一定存在于某个1M的大内存块里，而每个header都有其指针
	于是可以知道内存是否在 [该指针, 该指针+1M) 之间，如果不在，就继续看下一个header
	由于header只有16个，所以可以看成是常数时间
	然后再用 （内存地址 - 所在的1M内存的地址 ）/32 得到在哪个group中

	延迟归还
		当一个group的全部曾经被使用过的内存都归还后，它的计数器将会回到0，此时就可以认为它可以被回收
		但是并不会立刻回收，而是赋给全局变量。即延迟回收
		假如全局变量有值，说明已经存在一个正在等待延迟回收的group，则把那个group回收，这个group赋给全局变量
		计算机领域有很多这种类似的惰性行为，其目的都是为了降低高代价的函数的调用
		假若group立刻被回收，而下一次申请内存其他group都满足不了，则又要重新开辟这个group
		于是干脆备用吧。等下一个group被回收时才真正回收自己


	std.allocator 与 malloc 的比较
		allocator也维护了小区块内存链表；malloc亦是
		allocator减少了malloc的调用次数；malloc也减少了系统api的调用次数
		allocator直接从链表里拿出内存，速度很快；malloc也是，所以速度同样很快
		allocator没有cookie，使用了单链表，内存区块是裸露的，
		；malloc有cookie，使用双链表，内存区块被cookie包围，此外，物理上连续的内存还被栅栏包围
		allocator归还后的链表是无序的，无法判断其物理上的连续性，因此十分难以合并，亦无法归还，任由持有的内存不断增长
		；malloc可以通过cookie来判断是否可以合并，当一个group尽数回收后，可以归还

	为什么在malloc已有内存管理的基础上，allocator还要做类似的设计？
		只为解决巨量小内存所造成的cookie浪费，速度未有提升，反而还有内存无法归还的缺点
		因此除非真的需要，默认的内存分配行为已经够好
		默认的内存分配（malloc、第一std分配器）是世界上最好的程序员设计的
		已足够应对各种需求，只是不能满足特定场景而已

	malloc与allocator的相似设计会造成浪费吗？
		会。不仅如此，许多操作系统其实也有链表式的内存管理，所以算起来，这种管理行为套娃了三次
		但是操作系统、malloc、allocator三者是独立的。每层都不能假定上一层已经做了内存管理，因此每层都做了内存管理
		虽有浪费，并非坏事
		vc后面取消了malloc的内存管理。因为它与window是一家，必然已经沟通过，操作系统层已经做了内存管理了

*/