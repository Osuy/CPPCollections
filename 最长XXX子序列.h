#pragma once
/*
	子序列与字串不同
	子序列是从数组的任意位置去掉元素后的数组
	相当于子集，但是仍保持了元素在数组里的顺序

	子序列失去的连续的特征，因此可以分割成子问题，一般可以用动态规划来解决。
	子串依然保持连续特征，一般采用滑动窗口解决

	最大子数组和
		分解问题，如果已经求得前n-1个元素的最大子数组和，则n个元素的最大子数组和为：前n-1个元素的最大子数组和 + （最后一个元素 > 0? :最后一个元素 ：0）
			则Si = el[i]>0? (el[i]+S(i-1)): S(i-1)

	最长递增子序列
		dp[i]表示以i为结尾的最长递增子序列，则对于dp[i+1]
			筛选出所有0~i所有小于el[i+1]的元素，取dp的最大者
			dp[i+1]=max(dp[ k ∈ 0~i])(el[k]<el[i+1])


	最长公共子序列
		dp[i][j]表示，str1的前i-1个字符与str2的前j-1个字符的公共子序列的长度
		如果str[i] == str[j]，说明i和j所指的字符包含在公共子序列之内，
			dp[i][j] = dp[i-1][j-1] + 1

		如果str[i] != str[j]，说明不包含在公共子序列之内，要么i前移，要么j前移，取二者的较大值
			dp[i][j] = max(dp[i-1][j], dp[i][j-1])

	最长回文子串
		dp[i][j]表示i~j的子串是否构成回文串
		当长度小于2时，如果str[i] == str[j] 则true
		当长度大于2时，如果== 则dp[i][j] = dp[i+1][j-1];
					 如果!= 则dp[i][j] =false;

		由于dp[i][j] 依赖与dp[i+1][j-1]故，i从大到小迭代，j从小到大迭代

*/