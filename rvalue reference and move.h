#pragma once
#include <type_traits>

/*
	右值
		右值只能出现在 = 号的右边，是没有名称，无法寻址的，仅在产生的那一行有效
		相对的，左值是可以出现在=号左边，有名称，可以寻址的，产生后，在作用域内都有效
			int a = 5;//a是左值，5是右值
			5 = a; //5不能出现在等号左边

	右值引用
		传统引用，又称左值引用，只能引用左值
			int a = 5;
			int& b = a;
			int& c = 5;//5是右值，不能赋值给左值引用

		右值会在产生的那一行结束后失效，但可能希望右值能存在更长的时间，因此可以用右值引用引用一个右值
			int&& c = 5;//右值引用c 引用了右值5
		有这种需求也并不奇怪。因为右值是没有名称和地址的，但除了其所在的一行，可能其他地方也希望用到它
		可以值传递或引用的方式用到它，而如果右值是一个很大的数据，那么值传递的代价也就很大
		因此C++11出现了新语法，右值引用，可以以传引用的方式传递一个右值

		既然是引用，右值引用自然是可以对引用的对象进行修改的
			int&& a = 100;
			a = 99;//右值引用可以修改，即右值引用可以是左值
		
		倒不如说：
			右值不能在等号左边，左值、左值引用、右值引用都可以出现在等号左边

		常量在寄存器内，用完后就消失，引用一个常量会将其保存在常量区，因此一下三者是等价的
			const int a = 10;
			const int& a = 10;
			const int&& a = 10;

	
	移动构造和移动赋值
		开发中时常会有拷贝对象的情况，这时会调用拷贝构造函数
			class A{
				int* num;
			public:
				A(int* p): num(p) {}
				A(const A& o){ num = new int(o.num); }
			};
			A a1;
			A a2(a1);//利用拷贝构造，复制一个a1的副本a2
		类A具有指针成员，拷贝构造实现了深拷贝（假如类没有指针成员，则拷贝构造和移动构造都是累赘的）

		但是，可能会有这样的需求：使用一个临时变量来构造对象
		如果继续使用拷贝构造，就会效率低下，因为：
			1.深拷贝指针可能会引起很大开销
			2.创建临时变量，然后又深拷贝临时变量，最后临时变量释放。这当中内存分配两次、释放一次，而实际用到的只有一次内存分配

		即，对于临时变量，拷贝构造函数的效能不好，尤其是当类的成员指针指向大内存的数据
		正常人都会想到一个解决办法，临时变量的指针传递出来给要创建的变量，不就功德圆满了吗，而且也恰好只有一次内存分配
		没错，但是对于
			A::A(const A& o);
			左值引用是可以吸收右值引用的（参考引用折叠），但是传递时还用了const修饰，因此需要一个全新的，传递右值引用的拷贝构造

		也就是移动构造：
			A::A(A&& o){
				this->num = o.num;//o的指针赋值给自己
				o.num = nullptr;//o的指针指向空。那样，o析构时，不会影响自己
			}
		
		A a(A(new int(3)));//利用临时变量构造对象a
		但上面这个例子有点蹩脚，直接用接收 int*的构造函数不就好了吗？
		这并不是移动构造真正使用的场景。通常，在调用函数后得到一个返回值
		返回值一般都是按值传递的，并且是一个临时变量，如果利用这个返回值来构造，就会用到移动构造函数
			A func(...){
				A a;
				...
				return a;
			}
			A a(func(...));//func返回一个右值，于是调用移动构造

		有了移动构造，也有移动赋值操作符，原理相同，只是多了自我移动和先释放自己的指针：
			A& operator=(A&& o){
				if(&o == this)return;
				delete this->num;//先释放自己的指针，再获取临时对象的指针
				this->num = o.num;
				o.num = nullptr;
			}

	move
		从上面看，移动构造和移动赋值主要是利用临时变量来构造对象，转移临时变量的指针，
		避免二次分配内存，达到提高效率的目的

		但是仍然不能适用所有场景，比如：
			A a1(new int(3));
			A a2(a1);
		通过拷贝构造，深拷贝复制了a1的副本a2。但是，假如下一行代码是：
			destroy(a1); //释放a1，destroy是stl的析构工具
		即：复制一个a1的副本，然后释放掉a1（从使用意义上来讲，a1的使命完成了，将指针转交给a2）
		但是，这种转移使用的是拷贝构造，而非移动构造，仍然有内存二次释放和一次析构
		就是说，如果想要用一个左值（非临时变量）转移给新构造的对象，还是会调用拷贝构造，而我们希望的是调用移动构造

		实现也很简单，将左值、左值引用转换成右值引用，就会调用移动构造
		std::move的功能就是如此，其实现也很简单：

			template<class T>
			struct remove_reference
			{
				typedef T Type;
			}
			template<class T>
			struct remove_reference<T&>
			{
				typedef T Type;
			}
			template<class T>
			struct remove_reference<T&&>
			{
				typedef T Type;
			}
			//remove_referemce接收引用，会提取出其类型

			template<class T>
			remove_reference<T>::Type&& move(T&& t){
				return static_cast<remove_reference<T>::Type&&>(t);
			}
			根据引用折叠，t传值、引用，都会被处理为引用；传右值引用，会被处理为右值引用
			然后用remove_reference<T>::Type&&强制都转化为右值引用，return

		于是对于上面的例子，使用move，就能调用移动构造
			A a2(std::move(a1));//调用移动构造，a1的指针转移给a2

		你可能会发现，std::move其实啥都没做，就是将任何类型都转化为右值，
		因此，也可以理解为rvalue_cast
		经过move后的左值被转化为右值后，就会走移动改造、移动赋值，从而交出自己的指针
		（move不会修改对象，对象在被传入移动构造/拷贝时，才会失去指针。如果没有被用到，则被move的对象不会失效）


	完美转发
		完美转发和类没有太大的关系，它用于函数模板调用右值引用为参数的函数
		如何理解上面这句话呢？
		假设现在有以下两个参数：
			void func(int&);
			void func(int&&);
		现:
			int&& n = 5;
			func(5); //5是右值，调用版本2
			func(n); //n是右值引用，是一个左值，调用版本1
		这不符合我们的预期，我们希望func(n)调用的是版本1，因为我们传了一个右值引用啊！！！
		但是在语言层面：
			左值、左值引用、右值引用是左值
			只有右值是右值
		所以就会有，传3种调用版本1，只有传第四种，调用版本2

		然而，我们确实是希望传右值引用也调用版本2的。这就需要用到完美转发forward
		如下
			func(forward<int>(n));//调用版本2
		
		这就是forward的用法吗？不是。上面的例子种，写明了模板参数<int>，也就是说我知道n是int右值引用，
		但开发中，几乎不会有程序员知道：哦，这是右值引用，得用forward
		forward只用于函数模板中，并且自动推导类型，才能发挥最大作用
		

		现有：
			template<class T>
			void call_func(T&& t)
			{
				func(t);//情况1，总是调用版本1
				func(forward<T>(t));//情况2
			}

			首先介绍一下右值引用为参数的函数模板。其参数时T&&，由于自动类型推导和引用折叠，
			只有传右值时，T推导为T，其余情况都是推导为T&

			无论t传什么，情况1都调用版本1，因为t左值
			当传左值时，T推导为int&，由于引用折叠，t的类型时int&，forward<int&>(int&) = int& 调用版本1
			当传右值时，T推导为int，于是t的类型时int&&，forward<int>(int&&) = int&&，调用版本2

		forward解决了一个什么问题：
			如果一个函数将自己的形参传给一个重载的函数，
			那么永远只会调用接收左值的版本，而不会调用接收右值的版本
			因为右值形参在函数体内成为了右值引用，而右值引用是左值，所以只会调用接收左值的版本

			forward



		
			
*/

class A
{
public:
	A(int n) :_n(new int(n)) {}

	int getN() { return *_n; }
private:
	int* _n;
};

void test()
{
	A a(1);
	std::move(a);

	a.getN();
}